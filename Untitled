def estimate_convergence_order(df: pd.DataFrame, refinement_ratio: float = 2.0):
    """
    通过对整个误差轨迹的对数进行线性回归来估计收敛阶。

    参数:
    df (pd.DataFrame): DataFrame 中必须包含一个名为 'Error L2' 的列。
    refinement_ratio (float): 每次迭代的细化率，
                               例如，如果每次步长减半，则细化率为 2。
                               您的原始代码中 np.log2 隐含了该值为 2。
    """
    # 过滤掉非正数的误差值，因为无法取对数
    df_positive_error = df[df['Error L2'] > 0].copy()

    if len(df_positive_error) < 2:
        print("\n数据点不足（少于2个），无法估计收敛阶。")
        return

    # 误差的对数是我们的因变量 y
    log_error = np.log(df_positive_error['Error L2'].values)

    # 我们需要一个自变量 x。
    # 假设误差 E = C * h^p，其中 h 是步长。
    # 如果 h_i = h_0 / (refinement_ratio^i)，那么 log(E) ≈ C' - p * log(refinement_ratio) * i
    # 因此，log(Error) 与迭代次数 i 呈线性关系。
    iterations = np.arange(len(log_error))

    # 使用 polyfit 进行一阶多项式拟合（即线性拟合）
    # 返回值是 [斜率, 截距]
    slope, intercept = np.polyfit(iterations, log_error, 1)

    # 从斜率计算收敛阶 p
    # slope = -p * log(refinement_ratio)
    order = -slope / np.log(refinement_ratio)

    print(f"\nEstimated Convergence Order (from log-log slope): {order:.2f}")